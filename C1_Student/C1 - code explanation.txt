âœ… CODE EXPLANATION â€” StudentData Solidity Smart Contract

This Solidity program creates a simple student database using:

Structure (struct)

Dynamic Array

Functions for adding, viewing, and accessing student data

Validations using require() and revert()

This smart contract can be deployed on Ethereum Test Networks like Goerli, Sepolia, or Ganache.

ðŸ“Œ 1. SPDX License Identifier
//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

âœ” Explanation:

Required for Solidity compilation.

Declares license and specifies compiler version (0.8.x), which includes overflow protection.

ðŸ“Œ 2. Contract Declaration
contract StudentData {

âœ” Explanation:

Defines the smart contract named StudentData.
A smart contract is similar to a class in OOP.

ðŸ“Œ 3. Defining the Structure
struct Student {
    string name;
    uint rollno;
}

âœ” Explanation:

Creates a custom data type Student with:

name (string)

rollno (unsigned integer)

This struct stores information about each student.

ðŸ“Œ 4. Dynamic Array to Store Students
Student[] public studentArr;

âœ” Explanation:

Creates a dynamic array of Student objects.

Declared public, so Solidity automatically creates a getter function:

studentArr(i) returns student at index i.

ðŸ“Œ 5. Add New Student Function
function addStudent(string memory name, uint rollno) public {
    for(uint i = 0; i < studentArr.length; i++) {
        if(studentArr[i].rollno == rollno) {
            revert("Student with roll no already exists!");
        }
    }
    studentArr.push(Student(name, rollno));
}

âœ” Explanation:
Step-by-step:

Inputs: name and rollno.

Check for duplicates:
Loops through array to ensure no other student has the same roll number.

revert():
Immediately stops execution if duplicate roll number found.

Push student:
Adds a new Student struct into the array.

ðŸ” Why memory?

Strings are reference types in Solidity, so they must specify data location:

memory â†’ temporary storage used during function execution.

ðŸ“Œ 6. Display All Students
function displayAllStudents() public view returns(Student[] memory) {
    return studentArr;
}

âœ” Explanation:

Marked view, meaning it does not modify contract state.

Returns the full array of students.

Returned in memory because arrays cannot be returned directly from storage.

ðŸ“Œ 7. Get Student By Index
function getStudentByIndex(uint index) public view returns(Student memory) {
    require(index < studentArr.length || index > studentArr.length, "Index out of bound");
    return studentArr[index];
}

âœ” Explanation:

Returns student at a specific index.

Uses require() to check boundary conditions.

âš  NOTE:
This line has a logical mistake:

require(index < studentArr.length || index > studentArr.length, "Index out of bound");


Correct logic should be:

require(index < studentArr.length, "Index out of bound");


Because index > length does not make sense and will never allow valid access.

ðŸ“Œ 8. Get Length of Student Array
function getLengthOfStudents() public view returns(uint) {
    return studentArr.length;
}

âœ” Explanation:

Returns how many students are currently stored.

Useful for iterating or front-end display.

ðŸŽ¯ FINAL SUMMARY â€” What This Smart Contract Does

âœ” Uses struct to model student data
âœ” Stores multiple student records in a dynamic array
âœ” Prevents duplicate roll numbers using revert()
âœ” Provides functions to:

Add new student

Retrieve all students

Retrieve a student by index

Get total number of students stored

âœ” Demonstrates key Solidity concepts:

Structures

Arrays

Memory vs storage

Error handling (require, revert)

Public data getters