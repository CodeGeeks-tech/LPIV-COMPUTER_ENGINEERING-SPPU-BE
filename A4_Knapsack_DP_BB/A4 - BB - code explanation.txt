‚úÖ CODE EXPLANATION ‚Äì 0/1 Knapsack Using Branch and Bound

The Branch and Bound technique systematically explores subsets of items and prunes (cuts off) branches that cannot lead to an optimal solution.
This makes it faster than brute force, especially for large n.

üîπ 1. Item Class ‚Äì Represents Each Item
class Item:
    def __init__(self, value, weight):
        self.value = value
        self.weight = weight
        self.ratio = value / weight

‚úî Explanation:

Stores value, weight, and value/weight ratio.

Items will later be sorted by ratio in descending order (greedy upper bound).

üîπ 2. Node Class ‚Äì Represents a Node in the Search Tree
class Node:
    def __init__(self, level, profit, weight):
        self.level = level
        self.profit = profit
        self.weight = weight
        self.bound = 0.0

‚úî Explanation:

Each node represents:

level ‚Üí which item index we are considering

profit ‚Üí total profit collected so far

weight ‚Üí total weight so far

bound ‚Üí maximum possible profit reachable from this node (used for pruning)

This is essential for deciding whether to explore a branch.

üîπ 3. Bound Function ‚Äì Computes Upper Bound of Profit
def bound(u, n, W, arr):

‚úî Purpose:

Calculates the maximum theoretical profit reachable from a node, assuming we can take fractions of items (like fractional knapsack).

‚úî Step-by-step:
1. Check if node is already invalid:
if u.weight >= W:
    return 0


If weight already exceeds capacity ‚Üí this node is useless ‚Üí bound = 0.

2. Initialize profit and weight
profit_bound = u.profit
j = u.level + 1
totweight = u.weight

3. Add full items while possible
while j < n and totweight + arr[j].weight <= W:
    totweight += arr[j].weight
    profit_bound += arr[j].value
    j += 1


Adds next items fully until weight limit is reached.

4. Add fractional part of next item
if j < n:
    profit_bound += (W - totweight) * arr[j].ratio


This ensures the bound is optimistic, helping to prune effectively.

üîπ 4. Main Branch and Bound Function
def knapsack_branch_and_bound(W, arr, n):

‚úî Step 1: Sort items by decreasing ratio
arr.sort(key=lambda x: x.ratio, reverse=True)


Greedy order improves bounding efficiency.

‚úî Step 2: Initialize a queue for BFS
Q = Queue()
u = Node(-1, 0, 0)  # root node
v = Node(0, 0, 0)
Q.put(u)
maxProfit = 0


u is the root (no items considered yet)

BFS is used to explore promising branches.

üîπ 5. BFS Search Loop
while not Q.empty():
    u = Q.get()


Process each node one-by-one.

‚úî LEVEL CALCULATION
if u.level == -1:
    v.level = 0
elif u.level == n - 1:
    continue
else:
    v.level = u.level + 1


Moves to next item level.

üîπ 6. Case 1: Include Current Item
v.weight = u.weight + arr[v.level].weight
v.profit = u.profit + arr[v.level].value

‚úî If weight allowed, update max profit:
if v.weight <= W and v.profit > maxProfit:
    maxProfit = v.profit

‚úî Compute bound
v.bound = bound(v, n, W, arr)

‚úî Add to queue if promising
if v.bound > maxProfit:
    Q.put(Node(v.level, v.profit, v.weight))


This means:

If upper bound of node is still higher than current max profit ‚Üí explore it.

üîπ 7. Case 2: Exclude Current Item
v.weight = u.weight
v.profit = u.profit
v.bound = bound(v, n, W, arr)

‚úî Add if promising
if v.bound > maxProfit:
    Q.put(Node(v.level, v.profit, v.weight))

üîπ 8. Returning the Result
return maxProfit


At end of BFS, maxProfit contains best possible profit.

üîπ 9. Main Program Block

Handles user input:

n = int(input("Enter number of items: "))
items = []
for i in range(n):
    value = ...
    weight = ...
    items.append(Item(value, weight))


Reads values & weights for all items.

Builds list of Item objects.

Then:

W = int(input("Enter capacity of knapsack: "))
max_profit = knapsack_branch_and_bound(W, items, n)
print("\nMaximum profit using Branch and Bound =", max_profit)

‚≠ê Summary of Branch and Bound Knapsack
Feature	Explanation
Strategy	Systematically explores possibilities
Optimization	Prunes (cuts) unpromising branches using bounds
Bound Function	Uses fractional knapsack to estimate max possible profit
Data Structure	BFS using queue
Time Complexity	Better than brute-force but worst case exponential
Advantage	Efficient for medium-sized inputs