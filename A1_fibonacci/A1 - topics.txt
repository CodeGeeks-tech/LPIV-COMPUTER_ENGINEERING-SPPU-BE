Introduction
The Fibonacci sequence is a series of numbers in which each term is the sum of the two preceding terms, starting from 0 and 1. This problem demonstrates two approaches to generating Fibonacci numbers: a recursive approach and a non-recursive (iterative) approach. The recursive method closely follows the mathematical definition of Fibonacci numbers, while the iterative method computes values efficiently using loops. The aim of this experiment is to understand these two approaches, their differences, and their time and space complexities.

Recursive Fibonacci Method
The recursive method defines the Fibonacci sequence in terms of itself: F(n) = F(n–1) + F(n–2). This method uses a function that repeatedly calls itself to compute smaller subproblems until reaching the base cases F(0) = 0 and F(1) = 1. Although elegant and mathematically intuitive, this approach generates many repeated calculations and grows exponentially in time, making it inefficient for large n.

Recursive Time Complexity
The time complexity of the naive recursive Fibonacci function is O(2ⁿ) because each function call results in two additional calls, creating a binary recursion tree. This exponential growth causes a dramatic increase in computation time as n increases. Space complexity is O(n) because each recursive call adds a new frame to the call stack, resulting in linear stack space usage.

Recursive Space Complexity
Since recursion stores intermediate calls on the function call stack, the maximum depth reached is n. Therefore, the recursive approach needs space proportional to the depth of recursion. This becomes inefficient for larger Fibonacci numbers, as stack overflow can occur if recursion depth exceeds system limits.

Non-Recursive (Iterative) Fibonacci Method
The non-recursive or iterative method computes Fibonacci numbers using a simple loop. Starting with the first two numbers (0 and 1), the program repeatedly updates variables to generate each subsequent term. This method avoids repeated computations and does not require function calls, making it significantly faster and more memory-efficient than recursion.

Iterative Time Complexity
The iterative approach runs in O(n) time because it computes each Fibonacci number once using a single loop. There are no repeated subproblems or branching calls, making it optimal in terms of time for computing the n-th Fibonacci number sequentially.

Iterative Space Complexity
The space complexity of the iterative method is O(1), as it uses a constant number of variables regardless of n. This method is ideal for large values because it avoids recursion overhead and minimizes memory usage.

Comparison of Recursive vs Non-Recursive Methods
The recursive method is intuitive and mirrors the mathematical definition but suffers from exponential time complexity and stack usage. The iterative method, on the other hand, is faster, simpler, and more scalable. While recursion may be useful for learning and understanding divide-and-conquer techniques, the iterative version is preferred in real-world applications where efficiency matters.

Applications
Fibonacci numbers appear in computer algorithms, nature, mathematics, dynamic programming, financial modeling, and bioinformatics. Understanding how to compute Fibonacci numbers efficiently helps students learn optimization, recursion, iteration, and complexity analysis, which are fundamental topics in algorithm design and analysis.

Conclusion
This experiment demonstrates two methods of computing Fibonacci numbers and analyzes their performance differences. The recursive approach is straightforward but inefficient due to exponential time and high space usage, while the non-recursive approach is efficient and highly scalable. Studying both forms provides a strong foundation for understanding algorithmic efficiency and the importance of choosing optimal techniques in programming.