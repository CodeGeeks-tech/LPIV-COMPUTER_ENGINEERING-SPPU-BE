âœ… CODE EXPLANATION â€“ N-Queens Problem Using Backtracking

The N-Queens problem asks you to place N queens on an NÃ—N chessboard so that no two queens attack each other.
A queen can attack horizontally, vertically, and diagonallyâ€”so each placement must be carefully checked.

This program uses backtracking, a depth-first search strategy that tries placing queens row by row and backtracks when a conflict occurs.

ğŸ”¹ 1. print_board(board)
def print_board(board):
    for row in board:
        print(" ".join(row))
    print()

âœ” Explanation

Prints the entire chessboard in matrix form.

Each cell contains "Q" for queen or "0" for empty.

Joins each row with spaces for clean output.

ğŸ”¹ 2. is_safe(board, row, col, n)

This function checks whether it is safe to place a queen at (row, col).

âœ” (a) Check Same Column
for i in range(row):
    if board[i][col] == "Q":
        return False


Checks upwards in the same column.

Since we place queens row by row, only rows above need checking.

âœ” (b) Check Upper-Left Diagonal
i, j = row - 1, col - 1
while i >= 0 and j >= 0:
    if board[i][j] == "Q":
        return False
    i -= 1
    j -= 1


Moves diagonally left-up.

If a queen exists on this diagonal, placement is unsafe.

âœ” (c) Check Upper-Right Diagonal
i, j = row - 1, col + 1
while i >= 0 and j < n:
    if board[i][j] == "Q":
        return False
    i -= 1
    j += 1


Moves diagonally right-up.

Ensures no queen is attacking diagonally from the right.

âœ” If no conflicts found:
return True


The position (row, col) is safe for placing a queen.

ğŸ”¹ 3. solve_n_queens(board, row, n)

This is the core backtracking function.

âœ” Base Case
if row == n:
    print_board(board)
    return True


If all queens are successfully placed (row index reaches n),
â†’ print the solution
â†’ return True

Allows printing multiple solutions.

âœ” Recursive Case â€“ Try All Columns
res = False
for col in range(n):


Try placing a queen in each column of the current row.

âœ” If Position is Safe â†’ Place Queen
if is_safe(board, row, col, n):
    board[row][col] = "Q"


Place a queen tentatively.

âœ” Recurse to Next Row
res = solve_n_queens(board, row + 1, n) or res


Calls the function to place queens in the next row.

or res ensures all solutions are printed.

âœ” Backtracking Step
board[row][col] = "0"


Removes the queen if the placement doesnâ€™t lead to a solution.

This allows exploring other possibilities.

âœ” Return Status
return res


Returns True if at least one valid solution exists.

ğŸ”¹ 4. Main Program
n = int(input("Enter the size of the board (N): "))
board = [["0"] * n for _ in range(n)]


Takes board size from user.

Initializes an n Ã— n board with all zeros.

âœ” Start Solving
if not solve_n_queens(board, 0, n):
    print("No solution exists.")


Starts solving from row 0.

Prints a message if no solutions exist.

â­ Backtracking Flow Summary

Start with row 0

Try all columns in current row

If safe â†’ place queen

Move to next row

If conflict â†’ backtrack and try next column

Continue until all queens are placed

Print all valid arrangements

â­ Time & Space Complexity
Approach	Time Complexity	Space Complexity
Backtracking	O(N!)	O(NÂ²) (board storage)