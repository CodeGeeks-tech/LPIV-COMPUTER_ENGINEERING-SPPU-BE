1. What is Huffman Encoding?

Answer:
Huffman Encoding is a lossless data compression algorithm that assigns shorter binary codes to more frequent characters and longer codes to less frequent characters.

2. Why is Huffman Encoding considered a greedy algorithm?

Answer:
Because at each step it always picks the two nodes with the smallest frequencies, making the locally optimal choice to achieve a globally optimal prefix-free code.

3. What is the significance of frequency in Huffman Encoding?

Answer:
The frequency determines how short or long a character’s binary code will be — higher frequency ⇒ shorter code.

4. What data structure is used to build the Huffman tree?

Answer:
A min-heap (priority queue) is used so the smallest frequency nodes can be efficiently accessed.

5. What is a prefix-free code?

Answer:
A code system where no code is a prefix of another code. Huffman codes are naturally prefix-free.

6. What does the Node class represent in the given code?

Answer:
Each Node represents a character and its frequency, along with pointers to its left and right child nodes.

7. Why does the Node class define __lt__?

Answer:
To allow Python's heapq to compare Node objects based on frequency so they can be stored in a min-heap.

8. What happens inside the main Huffman loop (while len(heap) > 1)?

Answer:
The two nodes with the lowest frequency are removed, merged into a new parent node, and pushed back into the heap.

9. Why does the merged node have char = None?

Answer:
Because internal (non-leaf) nodes do not represent actual characters; only leaf nodes represent characters.

10. What binary code is assigned when traversing the tree?

Answer:
Left child gets "0" and right child gets "1".

11. What is the base case in print_codes()?

Answer:
When the node is None, the function returns (stops recursion).

12. Why can Huffman codes vary for the same input?

Answer:
Because nodes with equal frequencies may be combined in different orders, leading to different—but still valid—codes.

13. What is the time complexity of Huffman Encoding?

Answer:
O(n log n), where n is the number of distinct characters.

14. What is the space complexity of Huffman Encoding?

Answer:
O(n) for storing the tree and codes.

15. What does the program do if the input text has only one unique character?

Answer:
It assigns a code "0" to that character, since at least one bit is required.

16. Why do we use heapq.heapify()?

Answer:
It converts a list into a min-heap in O(n) time, allowing efficient extraction of minimum frequencies.

17. What is the purpose of using recursion in print_codes()?

Answer:
To perform a depth-first traversal of the Huffman tree and print all character codes.

18. What is the advantage of Huffman coding over fixed-length encoding?

Answer:
It reduces the average code length, leading to compressed data.

19. Can Huffman Encoding handle non-English characters?

Answer:
Yes, because it works on bytes/characters regardless of language.

20. What is the output of freq[ch] = freq.get(ch, 0) + 1?

Answer:
It counts how many times each character appears in the input text.

21. What happens if user inputs an empty string?

Answer:
Frequency dictionary is empty and Huffman Encoding won't work — need error checking (not included in code).

22. What are the leaf nodes in a Huffman tree?

Answer:
Nodes that contain actual characters (i.e., node.char is not None).

23. Why does the program print a header "Character | Huffman Code"?

Answer:
To clearly display each character and its corresponding binary Huffman code to the user.

24. What happens if two characters have the same frequency?

Answer:
The heap will order them based on insertion order or internal comparisons — but the final Huffman tree remains valid.

25. Why is Huffman Encoding lossless?

Answer:
Because every encoded string can be uniquely decoded using the prefix-free tree, ensuring no information is lost.