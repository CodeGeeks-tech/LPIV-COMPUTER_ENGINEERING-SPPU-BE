Introduction
Huffman Encoding is a lossless data compression algorithm that assigns variable-length codes to characters based on their frequencies. Characters that occur more frequently are assigned shorter codes, while less frequent characters receive longer codes. This method significantly reduces the total number of bits needed to represent text, making it one of the most widely used compression techniques. The algorithm is optimal and follows a greedy strategy to build the Huffman Tree.

Problem Definition
Given a text input, the goal is to encode each character using binary codes such that the overall size of the encoded message is minimized. This requires analyzing how frequently each character appears in the text and generating an optimal prefix-free code. The prefix-free property ensures that no encoded character is a prefix of another, making decoding unambiguous.

Greedy Strategy
Huffman Encoding uses a greedy approach by repeatedly selecting the two nodes with the smallest frequency and combining them into a new node with their combined frequency. This process continues until only one node remains, forming the root of the Huffman Tree. Greedy choice ensures that optimal combinations are formed at each step, resulting in the minimum weighted path length.

Priority Queue (Min-Heap) Usage
To efficiently extract the two smallest frequency nodes each time, a priority queue (implemented using a min-heap) is used. The heap contains nodes representing characters and combined frequency nodes. Each extraction takes O(log n) time, making the algorithm efficient even for large character sets. The heap structure is essential for maintaining the greedy order of selection.

Construction of Huffman Tree
Initially, every unique character is represented as a leaf node. The algorithm repeatedly removes the two lowest-frequency nodes, creates a parent node with their combined frequency, and inserts this node back into the heap. When only one node remains, it becomes the root of the Huffman Tree. Traversing left appends ‘0’ to the code, while traversing right appends ‘1’.

Generating Huffman Codes
Once the Huffman Tree is built, a recursive traversal generates binary codes for each character. Moving left assigns a ‘0’ and moving right assigns a ‘1’. The resulting codes are prefix-free and uniquely distinguishable. Frequent characters naturally appear near the root with shorter codes, minimizing the total encoding size.

Optimality of Huffman Coding
Huffman coding is proven to produce the optimal prefix-free binary code for a given set of character frequencies. Its greedy strategy ensures the best possible merge at each step, guaranteeing minimal weighted path length. This optimality makes it foundational in data compression algorithms.

Complexity Analysis
The time complexity of Huffman Encoding is O(n log n), where n is the number of unique characters. This comes primarily from heap operations during tree construction. The space complexity is O(n) because each character and internal node is stored in the tree. Efficient performance allows Huffman encoding to be used in large-scale compression systems.

Applications
Huffman coding is used in many real-world applications, including ZIP file compression, JPEG image encoding, MP3 audio encoding, and network data transfer. Its efficiency and lossless nature make it ideal for text compression and storage optimization.

Conclusion
This experiment demonstrates Huffman Encoding using a greedy strategy by constructing a Huffman Tree and assigning optimal prefix-free codes to characters based on frequency. The algorithm effectively reduces message size and showcases how greedy selection leads to globally optimal solutions. Huffman coding remains a core technique in the field of data compression and algorithm design.