1. What is the Fractional Knapsack problem?

Answer:
It is a greedy optimization problem where items can be broken into fractions to maximize profit within a weight capacity.

2. Why is the Fractional Knapsack solved using a greedy method?

Answer:
Because selecting the item with the highest value/weight ratio first always leads to the optimal solution.

3. What is the main difference between 0/1 Knapsack and Fractional Knapsack?

Answer:

0/1 Knapsack → Items cannot be broken; must take whole item.

Fractional Knapsack → Items can be taken partially.

4. What is the greedy choice made in this algorithm?

Answer:
Choosing items in decreasing order of value/weight ratio.

5. What does the expression x[1] / x[0] represent in the code?

Answer:
The value-to-weight ratio of each item.

6. Why do we sort items in descending order of ratio?

Answer:
To ensure the item giving the maximum profit per unit weight is selected first.

7. What is the time complexity of the fractional knapsack solution?

Answer:
O(n log n), because sorting dominates the runtime.

8. What is the space complexity of this algorithm?

Answer:
O(n) for storing weights and values.

9. Why are Python’s zip(weights, values) used in sorting?

Answer:
It pairs each weight with its corresponding value, allowing sorting by ratio.

10. When do we take a fractional part of an item?

Answer:
When the knapsack capacity is less than the weight of the next selected item.

11. How is the fractional part computed?

Answer:
res += value * (capacity / weight)
This adds proportional value based on available capacity.

12. Why does the loop break when capacity <= 0?

Answer:
Because the knapsack is full and no more weight can be added.

13. What would the algorithm return if capacity is greater than the total weight of items?

Answer:
The sum of all values, since all items can be taken fully.

14. What happens if an item has weight 0?

Answer:
Division by zero error will occur — such items must be filtered.
(This program does not check this.)

15. Why is the greedy approach optimal for this problem?

Answer:
Because fractional taking ensures always maximizing the gain per weight unit at every step.

16. What data type is used for weights and values in this code?

Answer:
Float → allows fractional precision.

17. Why is a new result variable res = 0.0 used?

Answer:
To accumulate the total maximum value of the selected items.

18. What does the algorithm output?

Answer:
Total maximum value achievable within the knapsack capacity.

19. What will happen if capacity = 0 at the start?

Answer:
Output will be 0, since no items can be taken.

20. What if all values are equal but weights differ?

Answer:
The algorithm selects the smallest-weight item first (highest ratio).

21. Why can Fractional Knapsack not use dynamic programming like 0/1 Knapsack?

Answer:
Because item fractions allow a greedy optimal solution; DP is unnecessary.

22. How does sorting with sorted(zip(...), reverse=True) behave?

Answer:
It sorts tuples (weight, value) by descending ratio.

23. What does the code return when capacity matches exactly the weight sum of full items?

Answer:
The sum of all item values with no fractional part.

24. Does the order of input items matter for the final result?

Answer:
No — they are sorted by ratio before processing.

25. In the sample input given, how is 240 computed?

Answer:

Take item1: weight10, value60

Take item2: weight20, value100

Take 2/3 of item3: 120 × (20/30) = 80
Total = 60 + 100 + 80 = 240