1. What is the 0/1 Knapsack problem?

Answer:
A problem where each item can either be taken completely (1) or not at all (0), and the goal is to maximize value without exceeding the weight capacity.

2. Why is it called 0/1 Knapsack?

Answer:
Because each item has only two choices: take it (1) or leave it (0) — no fractions allowed.

3. What approach does your given code use?

Answer:
It uses pure recursion (without dynamic programming).

4. What is the recurrence relation used in recursive knapsack?

Answer:
If weight > capacity:
  knapsack(W, n) = knapsack(W, n–1)
Else:
  knapsack(W, n) = max(value[n] + knapsack(W – wt[n], n–1), knapsack(W, n–1))

5. What are the base cases in the recursive knapsack function?

Answer:
When n < 0 or W <= 0, the result is 0.

6. What is the time complexity of this recursive solution?

Answer:
O(2ⁿ), exponential time.

7. Why is recursive knapsack slow for large inputs?

Answer:
Because it recomputes the same subproblems repeatedly (overlapping subproblems).

8. How does dynamic programming improve 0/1 Knapsack?

Answer:
DP stores intermediate results in a table (memoization or tabulation), reducing time complexity to O(nW).

9. What is the space complexity of the DP solution?

Answer:
O(nW) for the DP table.

10. What is the meaning of n in this program?

Answer:
It is the index of the current item being considered.

11. What happens when wt[n] > W?

Answer:
The item cannot be included, so only the recursive call without it is used.

12. What is the greedy strategy for knapsack?

Answer:
For 0/1 knapsack, greedy does not work because items cannot be broken — it only works for fractional knapsack.

13. How would you detect an optimal subset of items (not just total value)?

Answer:
By tracking decisions in DP table (keep a choice table or backtrack through DP matrix).

14. What is the advantage of Branch and Bound over recursion?

Answer:
Branch and Bound prunes unsafe branches using bounds, decreasing the number of recursive calls.

15. What is the bound function in Branch and Bound?

Answer:
A function that computes the maximum possible profit from the current node including fractional values, helping to prune branches.

16. What kind of tree does Branch & Bound use for Knapsack?

Answer:
A binary decision tree:
Left branch = include item
Right branch = exclude item

17. Why is the recursive function written as knapsack(W, n-1)?

Answer:
Because each recursive call processes the next item in sequence.

18. What is the result for the sample input?

Answer:
Maximum obtainable value = 220, by choosing items 2 and 3.

19. What is meant by overlapping subproblems?

Answer:
Different recursive calls compute the same values, e.g., knapsack(20,2) computed many times.

20. What is meant by optimal substructure?

Answer:
The optimal solution of the whole problem depends on optimal solutions of smaller subproblems.

21. Which algorithmic paradigm does 0/1 knapsack belong to?

Answer:
Dynamic Programming (when optimized)
Recursion (when naive)
Branch-and-Bound (for optimization with pruning)

22. Why does recursion use stack memory?

Answer:
Each recursive call stores local variables and execution state on the call stack.

23. What is the return type of the recursive function?

Answer:
An integer representing the maximum total value for the given capacity and items.

24. Why can’t fractional items be used in this program?

Answer:
Because it is a 0/1 knapsack, where items must be taken whole.

25. If capacity = 0 at the start, what is the output?

Answer:
0, because no items can be added.