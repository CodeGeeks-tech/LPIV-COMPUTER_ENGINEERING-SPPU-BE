âœ… CODE EXPLANATION â€“ 0/1 Knapsack Using Recursion

The 0/1 Knapsack problem is an optimization problem where each item can either be taken completely (1) or not taken at all (0).
This program solves the knapsack problem using pure recursion, following the classic definition of the 0/1 Knapsack.

ğŸ”¹ 1. Function Definition
def solve_knapsack():


Defines the main function that takes item inputs and computes the optimal value using recursion.

ğŸ”¹ 2. Taking Number of Items
n = int(input("Enter number of items: "))


Reads the number of items.

This controls how many values and weights will be taken.

ğŸ”¹ 3. Creating Lists for Values and Weights
val = []
wt = []


val[] stores the values (profits)

wt[] stores the weights of items.

ğŸ”¹ 4. Taking Value Input from User
print("Enter values of items:")
for i in range(n):
    val.append(int(input(f"Value of item {i+1}: ")))


Reads the value (profit) of each item.

Adds each value to the val list.

ğŸ”¹ 5. Taking Weight Input from User
print("Enter weights of items:")
for i in range(n):
    wt.append(int(input(f"Weight of item {i+1}: ")))


Reads the weight of each item.

Stores each weight in the wt list.

ğŸ”¹ 6. Taking Knapsack Capacity
W = int(input("Enter maximum weight capacity: "))


Reads the capacity (maximum weight) the knapsack can hold.

ğŸ”¹ 7. Recursive Knapsack Function
def knapsack(W, n):


This function returns the maximum possible value that can fit in a knapsack of capacity W using items 0â€¦n.

âœ” Base Case
if n < 0 or W <= 0:
    return 0


Meaning:

If no items are left â†’ return 0

If capacity becomes 0 â†’ return 0

âœ” Case 1: Item is Too Heavy
if wt[n] > W:
    return knapsack(W, n-1)


If the current item cannot fit into the knapsack,

Skip this item and check the remaining items.

âœ” Case 2: Choose Max of Two Options
return max(val[n] + knapsack(W - wt[n], n-1),
           knapsack(W, n-1))


This is the core logic of 0/1 knapsack:

Option 1 â†’ Include the item

Add its value val[n]

Reduce capacity by its weight: W - wt[n]

Recurse for remaining items

Option 2 â†’ Exclude the item

Ignore this item

Recurse only with smaller index

Take the maximum of the two possibilities.
ğŸ”¹ 8. Print Final Answer
print("\nMaximum value that can be obtained:", knapsack(W, n-1))


Calls the recursive knapsack function.

Starts with the last index: n-1.

Prints final maximum value.

ğŸ”¹ 9. Main Block
if __name__ == "__main__":
    solve_knapsack()


Ensures the function runs when the program is executed.

â­ Overall Flow Summary

Input number of items

Input value & weight of each item

Input knapsack capacity

Recursively compute best possible combination of items

Print the maximum achievable value

â­ Time & Space Complexity
Method	Time Complexity	Space Complexity
Recursive	O(2â¿)	O(n) (recursion depth)

This approach is slow for large n but ideal for academic understanding.