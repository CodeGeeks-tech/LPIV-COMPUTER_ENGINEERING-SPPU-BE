1. What is the Fibonacci series?

Answer:
A sequence where each term is the sum of the previous two terms. It begins as:
0, 1, 1, 2, 3, 5, 8, ...

2. What is the base case in the recursive Fibonacci function?

Answer:
If n <= 1, return n.
These base cases stop infinite recursion.

3. What is recursion?

Answer:
Recursion is a programming technique where a function calls itself to solve a smaller instance of the same problem.

4. What is the time complexity of the naive recursive Fibonacci function?

Answer:
O(2ⁿ), exponential time.

5. What is the time complexity of the iterative Fibonacci implementation?

Answer:
O(n), because it computes each term once in a loop.

6. Why is the recursive Fibonacci implementation slow?

Answer:
Because it recomputes the same values multiple times without storing results (no memoization).

7. What will happen if n = 0 in your program?

Answer:
Recursive output: 0
Iterative output: 0
(The series prints only a single 0)

8. How does the iterative approach work in this code?

Answer:
By starting with first = 0, second = 1 and using a loop to compute remaining terms.

9. What is backtracking? Is it used in this code?

Answer:
Backtracking is exploring all possibilities and reversing decisions.
Not used in Fibonacci — this code uses direct recursion, not backtracking.

10. What is the purpose of the for i in range(n) loop in the recursive section?

Answer:
It repeatedly calls recursive_fibonacci(i) to print each Fibonacci term sequentially.

11. What would be the output for input n = 1?

Answer:
Recursive: 0
Iterative: 0

12. What is the space complexity of the recursive Fibonacci function?

Answer:
O(n), due to the call stack depth.

13. What is the space complexity of the iterative Fibonacci function?

Answer:
O(1), constant space, since only three variables are used.

14. In the given code, what does first, second = second, third mean?

Answer:
It swaps the variables so that:

first becomes previous second

second becomes newly computed third

15. What will happen if we input a negative number?

Answer:
The recursive function returns the negative number (because n <= 1 triggers base case).
The iterative function prints incorrect results.
(Handling negatives is not implemented.)

16. How can you optimize the recursive Fibonacci function?

Answer:
Using dynamic programming or memoization.

17. Which method is more memory-efficient: recursion or iteration?

Answer:
Iteration.
Recursion uses call stack frames → more memory.

18. Why do we print first and second manually in the iterative version?

Answer:
Because the loop only handles terms from index 2 onward.

19. What is the difference between return and print in these functions?

Answer:
return passes the value back to the caller.
print displays the value on the screen.
Recursive function returns the value; iterative prints directly.

20. What happens if n = 2?

Answer:
Recursive:
0
1
Iterative:
0
1
(No loop executes because range(2,2) runs zero times.)

21. Which function is more suitable for large n and why?

Answer:
The iterative function, because it runs in linear time and uses constant memory.

22. What type of recursion is used in Fibonacci?

Answer:
Tree recursion (because each function calls itself twice).

23. What is a stack overflow? Can it happen here?

Answer:
A stack overflow occurs when too many recursive calls exhaust memory.
Yes, recursive Fibonacci with very large n will cause it.

24. How does Python handle recursive calls internally?

Answer:
It creates a call stack frame for each recursive call, storing parameters, return address, and local variables.

25. Write the Fibonacci series for n = 7 manually.

Answer:
0, 1, 1, 2, 3, 5, 8