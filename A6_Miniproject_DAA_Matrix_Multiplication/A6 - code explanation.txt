âœ… CODE EXPLANATION â€“ Sequential & Multithreaded Matrix Multiplication

This program performs matrix multiplication in three ways:

Sequential multiplication (normal method)

Multithreading: One thread per row

Multithreading: One thread per cell

It then measures performance, compares the execution time, and optionally displays the result matrix.

ðŸ“Œ 1. sequential_multiply(a, b)

Performs standard matrix multiplication.

def sequential_multiply(a, b):
    rows_a, cols_a, cols_b = len(a), len(a[0]), len(b[0])
    result = [[0] * cols_b for _ in range(rows_a)]

âœ” Explanation

a is of size (rows_a Ã— cols_a)

b is of size (cols_a Ã— cols_b)

Output matrix is (rows_a Ã— cols_b)

âœ” Triple nested loop (Standard Matrix Multiplication)
for i in range(rows_a):
    for j in range(cols_b):
        for k in range(cols_a):
            result[i][j] += a[i][k] * b[k][j]


Multiplies row from a with column from b.

Accumulates the dot product.

ðŸ“Œ 2. thread_per_row(a, b)

Creates one thread per row.

def thread_per_row(a, b):
    rows_a, cols_a, cols_b = len(a), len(a[0]), len(b[0])
    result = [[0] * cols_b for _ in range(rows_a)]

âœ” Inner function for each row
def compute_row(row):
    for j in range(cols_b):
        for k in range(cols_a):
            result[row][j] += a[row][k] * b[k][j]


Each thread computes one entire row of the result matrix.

âœ” Creating & starting threads
threads = [threading.Thread(target=compute_row, args=(i,)) for i in range(rows_a)]
for t in threads:
    t.start()
for t in threads:
    t.join()


Starts threads to compute rows in parallel.

join() waits for all threads to finish.

ðŸ‘‰ Advantages:

Only rows_a threads â†’ efficient, less overhead.

ðŸ“Œ 3. thread_per_cell(a, b)

Creates one thread per cell in the output matrix.

def thread_per_cell(a, b):
    result = [[0] * cols_b for _ in range(rows_a)]

âœ” Inner function to compute one result cell (i, j)
def compute_cell(row, col):
    for k in range(cols_a):
        result[row][col] += a[row][k] * b[k][col]

âœ” Creating many threads (rows Ã— columns)
threads = [threading.Thread(target=compute_cell, args=(i, j))
           for i in range(rows_a) for j in range(cols_b)]


If matrix = 10Ã—10 â†’ 100 threads

If matrix = 50Ã—50 â†’ 2500 threads (too many â†’ slow)

ðŸ‘‰ Why used only for small matrices?

Too many threads create overhead â†’ performance decreases.

ðŸ“Œ 4. Input Functions
âœ” Taking matrix from user
def input_matrix():
    rows = int(input("Enter number of rows: "))
    cols = int(input("Enter number of columns: "))

âœ” Printing matrix neatly
def print_matrix(matrix):
    for row in matrix:
        print([round(val, 2) for val in row])

ðŸ“Œ 5. Main Logic
âœ” Choosing input method:

Manual input

Random NxN matrix

choice = input("Enter choice (1 or 2): ")

âœ” Compatibility check
if len(a[0]) != len(b):
    print("Error: Matrix dimensions incompatible!")

ðŸ“Œ 6. Performance Measurement
âœ” Sequential Version
start = time.time()
r1 = sequential_multiply(a, b)
t1 = time.time() - start

âœ” Thread-per-row Version
start = time.time()
r2 = thread_per_row(a, b)
t2 = time.time() - start

âœ” Thread-per-cell Version (only for small matrices)
if len(a) * len(b[0]) <= 100:
    r3 = thread_per_cell(a, b)

ðŸ“Œ 7. Display Performance
Sequential:      0.0001s
Thread per row:  0.0003s
Thread per cell: 0.0005s

âœ” Speedup Calculation
Speedup = sequential_time / threaded_time

ðŸ“Œ 8. Output Matrix

For small matrices (â‰¤10Ã—10), it prints:

[19.0, 22.0]
[43.0, 50.0]

â­ Concepts Examiner May Ask
ðŸ”¸ Why multithreading?

To perform independent calculations in parallel.

ðŸ”¸ Why one thread per cell is slower?

Too many threads â†’ context switching overhead.

ðŸ”¸ Time complexities:
Method	Time Complexity
Sequential	O(nÂ³)
Thread per row	O(nÂ³ / n) = O(nÂ²) theoretically
Thread per cell	O(nÂ³ / nÂ²) = O(n) theoretically but in practice slower due to overhead
ðŸ”¸ Why join()?

Ensures all threads complete before accessing results.