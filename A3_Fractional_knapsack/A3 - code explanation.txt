âœ… CODE EXPLANATION â€“ Fractional Knapsack Using Greedy Method

The Fractional Knapsack problem allows taking fractions of items to maximize total profit.
This program implements the Greedy Approach, selecting items based on the highest value-to-weight ratio.

ðŸ”¹ 1. Function Definition
def fractional_knapsack():


Defines the function that performs the entire Fractional Knapsack process.

ðŸ”¹ 2. Input Section
n = int(input("Enter number of items: "))
weights = []
values = []


Takes the number of items from the user.

Creates two empty lists to store:

weights[]

values[]

ðŸ”¹ 3. Taking Weights and Values of Items
for i in range(n):
    w = float(input(f"Enter weight of item {i+1}: "))
    v = float(input(f"Enter value of item {i+1}: "))
    weights.append(w)
    values.append(v)

âœ” Explanation:

Loops through the number of items.

For each item:

Reads its weight

Reads its value

Stores them in respective lists.

ðŸ”¹ 4. Input Capacity of the Knapsack
capacity = float(input("Enter capacity of knapsack: "))
res = 0.0

âœ” Explanation:

capacity â†’ maximum weight the knapsack can hold.

res stores the final total maximum value obtained.

ðŸ”¹ 5. Sorting Items by Value-to-Weight Ratio
for weight, value in sorted(zip(weights, values), key=lambda x: x[1] / x[0], reverse=True):

âœ” Explanation:

Combines weights and values into pairs using zip().

Sorts items based on value/weight ratio in descending order.

This is the core greedy step:

Item giving maximum value per unit weight is selected first.

ðŸ”¹ 6. Filling the Knapsack
if capacity <= 0:
    break


If the bag is already full, stop the process.

âœ” Case 1 â€“ Item Fits Completely
if weight <= capacity:
    res += value
    capacity -= weight

Explanation:

If the item's weight is less than or equal to remaining capacity:

Take the full item.

Add its value to res.

Reduce knapsack capacity.

âœ” Case 2 â€“ Take Fraction of Item
else:
    res += value * (capacity / weight)
    capacity = 0

Explanation:

Item is too heavy, only part of it is taken.

Fraction taken = capacity / weight

Value added = value * fraction

After this, knapsack becomes full.

ðŸ”¹ 7. Printing Final Answer
print(f"\nMaximum value in Knapsack = {res:.2f}")


Prints the maximum possible profit with two decimal precision.

ðŸ”¹ 8. Main Block
if __name__ == "__main__":
    fractional_knapsack()


Ensures the program runs only when executed directly.

â­ Overall Flow Summary

Take item weights and values

Compute value/weight ratios

Sort items by highest ratio

Fill knapsack fully with best items

If the last item does not fit, take fraction

Output maximum achievable value

â­ Time & Space Complexity
Aspect	Complexity
Sorting	O(n log n)
Item selection loop	O(n)
Total Time Complexity	O(n log n)
Space Complexity	O(1) (excluding input lists)